This is Webtube, a Ruby implementation of the WebSocket protocol defined in
RFC 6455.


== Sample client

(Also see [[wsc]], a basic command line utility for talking to WebSocket
servers and included with the Webtube distribution.)

  require 'webtube'

  $webtube = Webtube.connect 'ws://echo.websocket.org/'
  $webtube.send_message 'Hello, echo server!'

  class << $listener = Object.new
    def onmessage webtube, message, opcode
      puts "The echo server says: #{message.inspect}"
      # We only care about one message.
      $webtube.close
      return
    end
  end
  $webtube.run $listener


== Sample server

(This code is also available as a separate file; see [[sample-server.rb]].)

  #! /usr/bin/ruby

  # A sample WEBrick server using the Webtube API.  It listens on port 8888 and
  # provides two services: [[/diag]], which logs all the events from
  # [[Webtube#run]] and remains silent towards the client (although note that
  # the Webtube library pongs the pings), and [[/echo]], which echos.

  require 'webrick'
  require 'webrick/httpservlet'
  require 'webtube/webrick'
  require 'set'

  class << diagnostic_listener = Object.new
    def respond_to? name
      return (name.to_s =~ /^on/ or super)
    end

    def method_missing name, *args
      output = "- #{name}("
      args.each_with_index do |arg, i|
        output << ', ' unless i.zero?
        if i.zero? and arg.is_a? Webtube then
          output << arg.to_s
        else
          output << arg.inspect
        end
      end
      output << ")"
      puts output
      return
    end
  end

  class << echo_listener = Object.new
    def onmessage webtube, data, opcode
      webtube.send_message data, opcode
      return
    end
  end

  server = WEBrick::HTTPServer.new(:Port => 8888)
  server.mount_webtube '/diag', diagnostic_listener
  server.mount_webtube '/echo', echo_listener

  begin
    server.start
  ensure
    server.shutdown
  end


== WebSocketCat's commands

Webtube comes with [[wsc]], a command line utility for talking to WebSocket
server.  A session might look like this:

    $ wsc ws://echo.websocket.org/
    Connecting to ws://echo.websocket.org/ ...
    | 101 Web Socket Protocol Handshake
    | connection: Upgrade
    | date: Fri, 10 Oct 2014 12:43:49 GMT
    | sec-websocket-accept: Uk2zpTKu2TaQtJ2esybCgeB89qk=
    | server: Kaazing Gateway
    | upgrade: websocket

    *** open
    Hello, server!
    <<< Hello, server!
    /ping
    (Ping sent.)
    *** pong ""
    /close 1001
    *** close

Prefixed with [[|]] is the HTTP response header from the server, with [[<<<]]
are incoming text messages (non-text messages are prefixed with [[<N<]] where N
is the message opcode), and with [[***]] are miscellaneous other events.  Lines
entered by user are sent to the server as text messages.  The user can invoke
some special commands using the slash prefix:

- [[/ping [message]]] sends a ping frame to the server,

- [[/close [status [explanation]]]] sends a close frame to the server.  The
  status code is specified as an unsigned decimal number.

- [[/N [payload]]] sends a message or control frame of opcode [[N]], given as a
  single hex digit, to the server.  Per protocol specification, [[/1]] is text
  message, [[/2]] is binary message, [[/8]] is close, [[/9]] is ping, [[/A]] is
  pong.  Other opcodes can have application-specific meaning.  Note that the
  specification requires kicking clients (or servers) who send messages so
  cryptic that the server (or client) can't understand them.

If you need to start a text message with a slash, you can double it for escape,
or you can use the explicit [[/1]] command.  EOF from the terminal is
equivalent to [[/close 1000]].
