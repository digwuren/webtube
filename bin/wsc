#! /usr/bin/ruby

# WebSocketCat, a primitive CLI tool for manually talking to WebSocket servers

require 'base64'
require 'getoptlong'
require 'webtube'

VERSION_DATA = "WebSocketCat 1.0.0 (Webtube 1.0.0)
Copyright (C) 2014 Andres Soolo
Copyright (C) 2014 Knitten Development Ltd.

Licensed under GPLv3+: GNU GPL version 3 or later
  <http://gnu.org/licenses/gpl.html>

This is free software: you are free to change and
redistribute it.

There is NO WARRANTY, to the extent permitted by law.

"

USAGE = "Usage: wsc [options] ws[s]://host[:port][/path]

Interact with a WebSocket server, telnet-style.

--header, -H=name:value
    Use the given HTTP header field in the request.

--insecure, -k
    Allow connecting to an SSL server with invalid certificate.

--help
    Print this usage.

--version
    Show version data.

Report bugs to: <dig@mirky.net>

"

ONLINE_HELP = "WebSocketCat's commands are slash-prefixed.

/ping [message]
  Send a ping frame to the server.

/close [status [explanation]]
  Send a close frame to the server.  The status code is specified as an
  unsigned decimal number.

/N [payload]
  Send a message or control frame of opcode [[N]], given as a single hex digit,
  to the server.  Per protocol specification, [[/1]] is text message, [[/2]] is
  binary message, [[/8]] is close, [[/9]] is ping, [[/A]] is pong.  Other
  opcodes can have application-specific meaning.  Note that the specification
  requires kicking clients (or servers) who send messages so cryptic that the
  server (or client) can't understand them.

/help
  Show this online help.

If you need to start a text message with a slash, you can double it for escape,
or you can use the explicit [[/1]] command.  EOF from stdin is equivalent to
[[/close 1000]].

"

$header = {} # lowercased field name => value
$insecure = false

$0 = 'wsc' # for [[GetoptLong]] error reporting
begin
  GetoptLong.new(
      ['--header', '-H', GetoptLong::REQUIRED_ARGUMENT],
      ['--insecure', '-k', GetoptLong::NO_ARGUMENT],
      ['--help', GetoptLong::NO_ARGUMENT],
      ['--version', GetoptLong::NO_ARGUMENT],
      ).each do |opt, arg|
    case opt
    when '--header' then
      name, value = arg.split /\s*:\s*/, 2
      if value.nil? then
        $stderr.puts "wsc: colon missing in argument to --header"
        exit 1
      end
      name.downcase!
      if $header[name] then
        # The value was specified multiple times.
        $header[name] += ", " + value
      else
        $header[name] = value
      end
    when '--insecure' then
      $insecure = true
    when '--help' then
      puts USAGE
      exit 0
    when '--version' then
      puts VERSION_DATA
      exit 0
    else
      raise 'assertion failed'
    end
  end
rescue GetoptLong::Error => e
  # no need to display; it has already been reported
  exit 1
end

unless ARGV.length == 1 then
  $stderr.puts "wsc: argument mismatch (exactly one needed)"
  exit 1
end

# The events incoming over the WebSocket will be listened to by this object,
# and promptly shown to the user.

class << $listener = Object.new
  def onopen webtube
    puts "*** open"
    return
  end

  def onmessage webtube, content, opcode
    if opcode == 1 then
      puts "<<< #{content}"
    else
      puts "<#{opcode}< #{content.inspect}"
    end
    return
  end

  def oncontrolframe webtube, frame
    # We'll ignore 9 (ping) and 10 (pong) here, as they are already processed
    # by handlers of their own.
    unless [9, 10].include? frame.opcode then
      puts "*#{'%X' % opcode}* #{frame.payload.inspect}"
    end
    return
  end

  def onping webtube, frame
    puts "*** ping #{frame.payload.inspect}"
    return
  end

  def onpong webtube, frame
    puts "*** pong #{frame.payload.inspect}"
    return
  end

  def onannoyedclose webtube, frame
    if frame.body.bytesize >= 2 then
      status_code, = frame.body.unpack 'n'
      message = frame.body.byteslice 2 .. -1
      message.force_encoding 'UTF-8'
      message.force_encoding 'ASCII-8BIT' unless message.valid_encoding?
      message = nil if message.empty?
    else
      status_code = nil
      message = nil
    end
    puts "*** annoyedclose #{status_code.inspect}" +
        (message ? " #{message.inspect}" : '')
    return
  end

  def onclose webtube
    puts "*** close"
    $send_thread.raise StopSendThread
    return
  end
end

class StopSendThread < Exception
end

puts "Connecting to #{ARGV.first} ..."

$webtube = Webtube.connect ARGV.first,
    header_fields: $header,
    allow_opcodes: 1 .. 15,
    ssl_verify_mode: $insecure ? OpenSSL::SSL::VERIFY_NONE : nil,
    on_http_response: proc{ |response|
      # Show the HTTP response to the user
      puts "| #{response.code} #{response.message}"
      response.each_key do |key|
        response.get_fields(key).each do |value|
          puts "| #{key}: #{value}"
        end
      end
      puts
    }

# [[$listener]] will send us, via [[$send_thread]], the [[StopSendThread]]
# exception when the other side goes away.
$send_thread = Thread.current

# [[Webtube#run]] will hog the whole thread it runs on, so we'll give it a
# thread of its own.
$recv_thread = Thread.new do
  begin
    $webtube.run $listener
  rescue Exception => e
    $stderr.puts "Exception in receive thread: #{$!}", $@
    $send_thread.exit 1 # terminate the main thread
  end
end

# Now, read user input and interpret commands.

begin
  until $stdin.eof? do
    line = $stdin.readline.chomp!
    case line
    when /\A\/(\/)/ then
      $webtube.send_message $1 + $'
    when /\A\/([0-9a-f])\b\s*/i then
      $webtube.send_message $', $1.hex
    when /\A\/ping\b\s*/ then
      $webtube.send_message $', Webtube::OPCODE_PING
      puts "(Ping sent.)"
    when /\A\/close\b\s*\Z/ then
      $webtube.close
      puts "(Close sent.)"
    when /\A\/close\b\s+(\d+)\s*/ then
      $webtube.close $1.to_i, $'
      puts "(Close sent.)"
    when /\A\/help\s*\Z/ then
      puts ONLINE_HELP
    else
      $webtube.send_message line
    end
  end
  $webtube.close
  $recv_thread.join
rescue StopSendThread
end
